diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-xaui.c b/arch/mips/cavium-octeon/executive/cvmx-helper-xaui.c
index 93a498d05184..27733d710355 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-xaui.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-xaui.c
@@ -121,58 +121,80 @@ int __cvmx_helper_xaui_enable(int interface)
 	union cvmx_gmxx_tx_int_en gmx_tx_int_en;
 	union cvmx_pcsxx_int_en_reg pcsx_int_en_reg;
 
+    cvmx_dprintf("COULD IT BE THE FEATURE CHECK FOR PKND??\n");
 	/* Setup PKND */
 	if (octeon_has_feature(OCTEON_FEATURE_PKND)) {
+      cvmx_dprintf("COULD IT BE THE FIRST CSR READ??\n");
 		gmx_cfg.u64 = cvmx_read_csr(CVMX_GMXX_PRTX_CFG(0, interface));
+        cvmx_dprintf("COULD IT BE THE second CSR READ??\n");
 		gmx_cfg.s.pknd = cvmx_helper_get_ipd_port(interface, 0);
+        cvmx_dprintf("COULD IT BE THE third CSR /write READ??\n");
 		cvmx_write_csr(CVMX_GMXX_PRTX_CFG(0, interface), gmx_cfg.u64);
 	}
 
 	/* (1) Interface has already been enabled. */
 
 	/* (2) Disable GMX. */
+    cvmx_dprintf("step2 start!?? could it be the csr read??\n");
 	xauiMiscCtl.u64 = cvmx_read_csr(CVMX_PCSXX_MISC_CTL_REG(interface));
 	xauiMiscCtl.s.gmxeno = 1;
+    cvmx_dprintf("step2 could it be the csr write to disable gmx??\n");
 	cvmx_write_csr(CVMX_PCSXX_MISC_CTL_REG(interface), xauiMiscCtl.u64);
 
 	/* (3) Disable GMX and PCSX interrupts. */
+    cvmx_dprintf("step3 start. could it be the csr read??\n");
 	gmx_rx_int_en.u64 = cvmx_read_csr(CVMX_GMXX_RXX_INT_EN(0, interface));
+    cvmx_dprintf("step3 start. could it be the write for disabling interrupts???\n");
 	cvmx_write_csr(CVMX_GMXX_RXX_INT_EN(0, interface), 0x0);
+    cvmx_dprintf("step3 start. could it be read for setting up the gmx_tx_int_en???\n");
 	gmx_tx_int_en.u64 = cvmx_read_csr(CVMX_GMXX_TX_INT_EN(interface));
+    cvmx_dprintf("step3 start. could it be the cvmx_gmxx write???\n");
 	cvmx_write_csr(CVMX_GMXX_TX_INT_EN(interface), 0x0);
+    cvmx_dprintf("step3 start almost done. show up tell us about the PCSXX write???\n");
 	pcsx_int_en_reg.u64 = cvmx_read_csr(CVMX_PCSXX_INT_EN_REG(interface));
+    cvmx_dprintf("step3, this final csr write?\n");
 	cvmx_write_csr(CVMX_PCSXX_INT_EN_REG(interface), 0x0);
 
 	/* (4) Bring up the PCSX and GMX reconciliation layer. */
 	/* (4)a Set polarity and lane swapping. */
 	/* (4)b */
+    cvmx_dprintf("4.1\n");
 	gmxXauiTxCtl.u64 = cvmx_read_csr(CVMX_GMXX_TX_XAUI_CTL(interface));
 	/* Enable better IFG packing and improves performance */
 	gmxXauiTxCtl.s.dic_en = 1;
 	gmxXauiTxCtl.s.uni_en = 0;
+    cvmx_dprintf("4.2\n");
 	cvmx_write_csr(CVMX_GMXX_TX_XAUI_CTL(interface), gmxXauiTxCtl.u64);
 
 	/* (4)c Aply reset sequence */
+    cvmx_dprintf("4.3\n");
 	xauiCtl.u64 = cvmx_read_csr(CVMX_PCSXX_CONTROL1_REG(interface));
 	xauiCtl.s.lo_pwr = 0;
 
 	/* Issuing a reset here seems to hang some CN68XX chips. */
 	if (!OCTEON_IS_MODEL(OCTEON_CN68XX_PASS1_X) &&
-	    !OCTEON_IS_MODEL(OCTEON_CN68XX_PASS2_X))
+	    !OCTEON_IS_MODEL(OCTEON_CN68XX_PASS2_X) &&
+        0)
 		xauiCtl.s.reset = 1;
 
+    cvmx_dprintf("4.4\n");
 	cvmx_write_csr(CVMX_PCSXX_CONTROL1_REG(interface), xauiCtl.u64);
 
+    cvmx_dprintf("4.5\n");
 	/* Wait for PCS to come out of reset */
 	if (CVMX_WAIT_FOR_FIELD64
 	    (CVMX_PCSXX_CONTROL1_REG(interface), union cvmx_pcsxx_control1_reg,
 	     reset, ==, 0, 10000))
 		return -1;
+
+    cvmx_dprintf("4.6\n");
 	/* Wait for PCS to be aligned */
 	if (CVMX_WAIT_FOR_FIELD64
 	    (CVMX_PCSXX_10GBX_STATUS_REG(interface),
 	     union cvmx_pcsxx_10gbx_status_reg, alignd, ==, 1, 10000))
 		return -1;
+
+    cvmx_dprintf("4.7\n");
 	/* Wait for RX to be ready */
 	if (CVMX_WAIT_FOR_FIELD64
 	    (CVMX_GMXX_RX_XAUI_CTL(interface), union cvmx_gmxx_rx_xaui_ctl,
@@ -180,8 +202,11 @@ int __cvmx_helper_xaui_enable(int interface)
 		return -1;
 
 	/* (6) Configure GMX */
+    cvmx_dprintf("6.1\n");
 	gmx_cfg.u64 = cvmx_read_csr(CVMX_GMXX_PRTX_CFG(0, interface));
+
 	gmx_cfg.s.en = 0;
+    cvmx_dprintf("6.2\n");
 	cvmx_write_csr(CVMX_GMXX_PRTX_CFG(0, interface), gmx_cfg.u64);
 
 	/* Wait for GMX RX to be idle */
@@ -189,62 +214,87 @@ int __cvmx_helper_xaui_enable(int interface)
 	    (CVMX_GMXX_PRTX_CFG(0, interface), union cvmx_gmxx_prtx_cfg,
 		    rx_idle, ==, 1, 10000))
 		return -1;
+    cvmx_dprintf("6.3\n");
 	/* Wait for GMX TX to be idle */
 	if (CVMX_WAIT_FOR_FIELD64
 	    (CVMX_GMXX_PRTX_CFG(0, interface), union cvmx_gmxx_prtx_cfg,
 		    tx_idle, ==, 1, 10000))
 		return -1;
 
+    cvmx_dprintf("6.4\n");
 	/* GMX configure */
 	gmx_cfg.u64 = cvmx_read_csr(CVMX_GMXX_PRTX_CFG(0, interface));
 	gmx_cfg.s.speed = 1;
 	gmx_cfg.s.speed_msb = 0;
 	gmx_cfg.s.slottime = 1;
+    cvmx_dprintf("6.5\n");
 	cvmx_write_csr(CVMX_GMXX_TX_PRTS(interface), 1);
+    cvmx_dprintf("6.6\n");
 	cvmx_write_csr(CVMX_GMXX_TXX_SLOT(0, interface), 512);
+    cvmx_dprintf("6.7\n");
 	cvmx_write_csr(CVMX_GMXX_TXX_BURST(0, interface), 8192);
+    cvmx_dprintf("6.8\n");
 	cvmx_write_csr(CVMX_GMXX_PRTX_CFG(0, interface), gmx_cfg.u64);
 
 	/* (7) Clear out any error state */
+    cvmx_dprintf("7.1\n");
 	cvmx_write_csr(CVMX_GMXX_RXX_INT_REG(0, interface),
 		       cvmx_read_csr(CVMX_GMXX_RXX_INT_REG(0, interface)));
+    cvmx_dprintf("7.2\n");
 	cvmx_write_csr(CVMX_GMXX_TX_INT_REG(interface),
 		       cvmx_read_csr(CVMX_GMXX_TX_INT_REG(interface)));
+    cvmx_dprintf("7.3\n");
 	cvmx_write_csr(CVMX_PCSXX_INT_REG(interface),
 		       cvmx_read_csr(CVMX_PCSXX_INT_REG(interface)));
 
+    cvmx_dprintf("7.4\n");
 	/* Wait for receive link */
 	if (CVMX_WAIT_FOR_FIELD64
 	    (CVMX_PCSXX_STATUS1_REG(interface), union cvmx_pcsxx_status1_reg,
 	     rcv_lnk, ==, 1, 10000))
 		return -1;
+    cvmx_dprintf("7.5\n");
 	if (CVMX_WAIT_FOR_FIELD64
 	    (CVMX_PCSXX_STATUS2_REG(interface), union cvmx_pcsxx_status2_reg,
 	     xmtflt, ==, 0, 10000))
 		return -1;
+    cvmx_dprintf("7.6\n");
 	if (CVMX_WAIT_FOR_FIELD64
 	    (CVMX_PCSXX_STATUS2_REG(interface), union cvmx_pcsxx_status2_reg,
 	     rcvflt, ==, 0, 10000))
 		return -1;
 
+    cvmx_dprintf("7.7\n");
 	cvmx_write_csr(CVMX_GMXX_RXX_INT_EN(0, interface), gmx_rx_int_en.u64);
+    cvmx_dprintf("7.8\n");
 	cvmx_write_csr(CVMX_GMXX_TX_INT_EN(interface), gmx_tx_int_en.u64);
+    cvmx_dprintf("7.9\n");
 	cvmx_write_csr(CVMX_PCSXX_INT_EN_REG(interface), pcsx_int_en_reg.u64);
 
 	/* (8) Enable packet reception */
 	xauiMiscCtl.s.gmxeno = 0;
+    cvmx_dprintf("8.1\n");
 	cvmx_write_csr(CVMX_PCSXX_MISC_CTL_REG(interface), xauiMiscCtl.u64);
 
+    cvmx_dprintf("8.2\n");
 	gmx_cfg.u64 = cvmx_read_csr(CVMX_GMXX_PRTX_CFG(0, interface));
 	gmx_cfg.s.en = 1;
+    cvmx_dprintf("8.3\n");
 	cvmx_write_csr(CVMX_GMXX_PRTX_CFG(0, interface), gmx_cfg.u64);
 
+    cvmx_dprintf("8.4\n");
 	__cvmx_interrupt_pcsx_intx_en_reg_enable(0, interface);
+    cvmx_dprintf("8.5\n");
 	__cvmx_interrupt_pcsx_intx_en_reg_enable(1, interface);
+    cvmx_dprintf("8.6\n");
 	__cvmx_interrupt_pcsx_intx_en_reg_enable(2, interface);
+    cvmx_dprintf("8.7\n");
 	__cvmx_interrupt_pcsx_intx_en_reg_enable(3, interface);
+    cvmx_dprintf("8.8\n");
 	__cvmx_interrupt_pcsxx_int_en_reg_enable(interface);
+    cvmx_dprintf("8.9\n");
 	__cvmx_interrupt_gmxx_enable(interface);
+    cvmx_dprintf("8.10\n");
 
 	return 0;
 }
